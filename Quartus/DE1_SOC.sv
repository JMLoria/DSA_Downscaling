
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);


//=======================================================
//  REG/logic declarations
//=======================================================

localparam DW = 32;

logic clk;
logic resetn;
logic configure;
logic up;
logic down;
logic ready;
logic [15:0] bcd_out;
logic [15:0] bin_in;

logic tdi;
logic tdo;              
logic [1:0] ir_in;
// logic ir_out;
logic virtual_state_cdr;
logic virtual_state_sdr;
// logic virtual_state_e1d;
// logic virtual_state_pdr;
// logic virtual_state_e2d;
logic virtual_state_udr;
// logic virtual_state_cir;
// logic virtual_state_uir;
logic tck;              

logic [(DW-1):0] jtag_data;

// Instruction handler signals
logic        i_mode_select;
logic        debug_mode;
logic [8:0]  img_width;
logic [8:0]  img_height;
logic [2:0]  N_simd;
logic [7:0]  scale_factor;
logic [31:0] response_data;
logic        start;

// Memory interface signals
logic [31:0] i_mem_rdata;
logic        o_mem_we;
logic [3:0]  o_mem_byte_en;
logic [15:0] o_mem_addr_handler;
logic [31:0] o_mem_wdata;

// DSA system signals
logic [15:0] dsa_mem_addr;
logic        dsa_mem_we;
logic [3:0]  dsa_mem_byte_en;
logic [31:0] dsa_mem_wdata;
logic        dsa_busy;
logic        dsa_done;
logic [15:0] inv_scale;

// Manual memory address control
logic [15:0] manual_mem_addr;
logic [15:0] o_mem_addr;

// Address multiplexer control (SW[0]: 0=handler, 1=manual, SW[1]: DSA control)
logic addr_select;
logic dsa_active;

logic waiting_command;
logic debug_signal;


//=======================================================
//  Structural coding
//=======================================================

assign  clk = CLOCK_50;
assign  configure = ~KEY[0];
assign  up        = ~KEY[1];
assign  resetn    = KEY[2];
assign  down     = ~KEY[3];

// Address source selection: SW[0] = 0 -> instruction handler, SW[0] = 1 -> manual (keys)
// SW[1] = DSA active (overrides other sources when processing)
assign addr_select = SW[0];
assign dsa_active = dsa_busy;  // Use DSA addresses when processing

// Memory address and control multiplexer
logic        o_mem_we_handler;
logic [3:0]  o_mem_byte_en_handler;
logic [31:0] o_mem_wdata_handler;

always_comb begin
    if (dsa_active) begin
        o_mem_addr = dsa_mem_addr;
        o_mem_we = dsa_mem_we;
        o_mem_byte_en = dsa_mem_byte_en;
        o_mem_wdata = dsa_mem_wdata;
    end else if (addr_select) begin
        o_mem_addr = manual_mem_addr;
        o_mem_we = 1'b0;
        o_mem_byte_en = 4'b0000;
        o_mem_wdata = 32'h0;
    end else begin
        o_mem_addr = o_mem_addr_handler;
        o_mem_we = o_mem_we_handler;
        o_mem_byte_en = o_mem_byte_en_handler;
        o_mem_wdata = o_mem_wdata_handler;
    end
end

// Calculate inv_scale from scale_factor (inv_scale = 256 / scale_factor)
assign inv_scale = (scale_factor != 0) ? (16'd256 / {8'd0, scale_factor}) : 16'd256;

// Address controller module with proper debouncing
address_controller u_address_controller (
    .clk      (clk),
    .rst_n    (resetn),
    .key_inc  (KEY[1]),       // KEY[1] to increment
    .key_dec  (KEY[3]),       // KEY[3] to decrement
    .address  (manual_mem_addr)
);

vjtag u_vjtag (
                    .tdi                (tdi),                // jtag.tdi
                    .tdo                (tdo),                //.tdo
                    .ir_in              (ir_in),              //.ir_in
                    .ir_out             (),                   //.ir_out
                    .virtual_state_cdr  (virtual_state_cdr),  //.virtual_state_cdr
                    .virtual_state_sdr  (virtual_state_sdr),  //.virtual_state_sdr
                    .virtual_state_e1dr (),                   //.virtual_state_e1dr
                    .virtual_state_pdr  (),                   //.virtual_state_pdr
                    .virtual_state_e2dr (),                   //.virtual_state_e2dr
                    .virtual_state_udr  (virtual_state_udr),  //.virtual_state_udr
                    .virtual_state_cir  (),                   //.virtual_state_cir
                    .virtual_state_uir  (),                   //.virtual_state_uir
                    .tck                (tck)                 //  tck.clk
                    );

vjtag_interface  #(.DW(DW)) u_vjtag_interface (
                        .tck(tck),
                        .tdi(tdi),
                        .aclr(resetn),
                        .ir_in(ir_in),
                        .v_sdr(virtual_state_sdr),
                        .v_cdr(virtual_state_cdr),
                        .udr(virtual_state_udr),
                        .data_out(jtag_data),
                        .data_in(i_mem_rdata),
                        .tdo(tdo),
                        .debug_dr1(),
                        .debug_dr2()
                       );

// Instruction handler
instruction_handler u_instruction_handler (
                        .clk(clk),
                        .reset_n(resetn),
                        .ir_in(ir_in),
                        .instruction(jtag_data),
                        .i_mode_select(i_mode_select),
                        .debug_mode(debug_mode),
                        .img_width(img_width),
                        .img_height(img_height),
                        .N_simd(N_simd),
                        .scale_factor(scale_factor),
                        .i_mem_rdata(i_mem_rdata),
                        .o_mem_we(o_mem_we_handler),
                        .o_mem_byte_en(o_mem_byte_en_handler),
                        .o_mem_addr(o_mem_addr_handler),
                        .o_mem_wdata(o_mem_wdata_handler),
                        .response_data(response_data),
                        .start(start),
                        .waiting_command(waiting_command),
                        .debug_signal(debug_signal)
                       );

// DSA System Top (image processing)
dsa_system_top u_dsa_system (
                        .clk(clk),
                        .rst_n(resetn),
                        .i_start(start),
                        .i_mode_select(i_mode_select),
                        .o_busy(dsa_busy),
                        .o_done(dsa_done),
                        .i_step_mode(debug_mode),
                        .i_step_trig(~KEY[0]),
                        .i_img_width(img_width),
                        .i_img_height(img_height),
                        .i_inv_scale(inv_scale),
                        .o_mem_addr(dsa_mem_addr),
                        .o_mem_we(dsa_mem_we),
                        .o_mem_byte_en(dsa_mem_byte_en),
                        .o_mem_wdata(dsa_mem_wdata),
                        .i_mem_rdata(i_mem_rdata)
                       );

// Memory interface
memory_interface u_memory_interface (
                        .clk(clk),
                        .rst_n(resetn),
                        .o_mem_we(o_mem_we),
                        .o_mem_byte_en(o_mem_byte_en),
                        .o_mem_addr(o_mem_addr),
                        .o_mem_wdata(o_mem_wdata),
                        .i_mem_rdata(i_mem_rdata)
                       );

// 7-segment display for memory data [23:0]
bin2seven_seg u_bin2seven_seg0 (
                        .bin   (o_mem_addr[3:0]),
                        .seg   (HEX0)
                       );
bin2seven_seg u_bin2seven_seg1 (
                        .bin   (o_mem_addr[7:4]),
                        .seg   (HEX1)
                       );
bin2seven_seg u_bin2seven_seg2 (
                        .bin   (o_mem_addr[11:8]),
                        .seg   (HEX2)
                       );
bin2seven_seg u_bin2seven_seg3 (
                        .bin   (o_mem_addr[15:12]),
                        .seg   (HEX3)
                       );
bin2seven_seg u_bin2seven_seg4 (
                        .bin   (img_width),
                        .seg   (HEX4)
                       );
bin2seven_seg u_bin2seven_seg5 (
                        .bin   (img_height),
                        .seg   (HEX5)
                       );

// LEDs display status
assign LEDR[0] = start;
assign LEDR[1] = dsa_busy;
assign LEDR[2] = dsa_done;
assign LEDR[3] = waiting_command;
assign LEDR[4] = debug_signal;
assign LEDR[5] = o_mem_we;
assign LEDR[6] = dsa_active;
assign LEDR[7] = addr_select;
assign LEDR[8] = i_mode_select;
assign LEDR[9] = SW[3];


endmodule
