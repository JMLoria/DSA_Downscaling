
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);


//=======================================================
//  REG/WIRE declarations
//=======================================================

localparam DW = 32;

wire clk;
wire resetn;
wire configure;
wire up;
wire down;
wire ready;
wire [15:0] bcd_out;
wire [15:0] bin_in;

wire tdi;
wire tdo;              
wire [1:0] ir_in;
// wire ir_out;
wire virtual_state_cdr;
wire virtual_state_sdr;
// wire virtual_state_e1d;
// wire virtual_state_pdr;
// wire virtual_state_e2d;
wire virtual_state_udr;
// wire virtual_state_cir;
// wire virtual_state_uir;
wire tck;              

wire [(DW-1):0] jtag_data;
reg [(DW-1):0] counter;

// Instruction handler signals
wire        i_mode_select;
wire        debug_mode;
wire [8:0]  img_width;
wire [8:0]  img_height;
wire [2:0]  N_simd;
wire [7:0]  scale_factor;
wire [31:0] response_data;
wire        start;

// Memory interface signals
wire [31:0] i_mem_rdata;
wire        o_mem_we;
wire [3:0]  o_mem_byte_en;
wire [15:0] o_mem_addr_handler;
wire [31:0] o_mem_wdata;

// Manual memory address control
wire [15:0] manual_mem_addr;
wire [15:0] o_mem_addr;

// Address multiplexer control
wire addr_select;


//=======================================================
//  Structural coding
//=======================================================

assign  clk = CLOCK_50;
assign  configure = ~KEY[0];
// assign  up        = ~KEY[1];
assign  resetn    = KEY[2];
// assign  ready     = ~KEY[3];

// Address source selection: SW[0] = 0 -> instruction handler, SW[0] = 1 -> manual (keys)
assign addr_select = SW[0];
assign o_mem_addr = addr_select ? manual_mem_addr : o_mem_addr_handler;

// Manual address control using keys
always_ff @(negedge KEY[3] or negedge KEY[1] or negedge resetn) begin
    if (!resetn) begin
        manual_mem_addr <= 16'd0;
    end else
    if (!KEY[1]) begin
        manual_mem_addr <= manual_mem_addr + 16'h0004;
    end else if (!KEY[3]) begin
        manual_mem_addr <= manual_mem_addr - 16'h0004;
    end
end

vjtag u_vjtag (
                    .tdi                (tdi),  // jtag.tdi
                    .tdo                (tdo),  //.tdo
                    .ir_in              (ir_in),  //.ir_in
                    .ir_out             (),  //.ir_out
                    .virtual_state_cdr  (virtual_state_cdr),  //.virtual_state_cdr
                    .virtual_state_sdr  (virtual_state_sdr),  //.virtual_state_sdr
                    .virtual_state_e1dr (),  //.virtual_state_e1dr
                    .virtual_state_pdr  (),  //.virtual_state_pdr
                    .virtual_state_e2dr (),  //.virtual_state_e2dr
                    .virtual_state_udr  (virtual_state_udr),  //.virtual_state_udr
                    .virtual_state_cir  (),  //.virtual_state_cir
                    .virtual_state_uir  (),  //.virtual_state_uir
                    .tck                (tck)   //  tck.clk
                    );

vjtag_interface  #(.DW(DW)) u_vjtag_interface (
                        .tck(tck),
                        .tdi(tdi),
                        .aclr(resetn),
                        .ir_in(ir_in),
                        .v_sdr(virtual_state_sdr),
                        .v_cdr(virtual_state_cdr),
                        .udr(virtual_state_udr),
                        .data_out(jtag_data),
                        .data_in(counter),
                        .tdo(tdo),
                        .debug_dr1(),
                        .debug_dr2()
                       );

// Instruction handler
instruction_handler u_instruction_handler (
                        .clk(clk),
                        .reset_n(resetn),
                        .ir_in(ir_in),
                        .instruction(jtag_data),
                        .i_mode_select(i_mode_select),
                        .debug_mode(debug_mode),
                        .img_width(img_width),
                        .img_height(img_height),
                        .N_simd(N_simd),
                        .scale_factor(scale_factor),
                        .i_mem_rdata(i_mem_rdata),
                        .o_mem_we(o_mem_we),
                        .o_mem_byte_en(o_mem_byte_en),
                        .o_mem_addr(o_mem_addr_handler),
                        .o_mem_wdata(o_mem_wdata),
                        .response_data(response_data),
                        .start(start)
                       );

// Memory interface
memory_interface u_memory_interface (
                        .clk(clk),
                        .rst_n(resetn),
                        .o_mem_we(o_mem_we),
                        .o_mem_byte_en(o_mem_byte_en),
                        .o_mem_addr(o_mem_addr),
                        .o_mem_wdata(o_mem_wdata),
                        .i_mem_rdata(i_mem_rdata)
                       );

// 7-segment display for memory data [23:0]
bin2seven_seg u_bin2seven_seg0 (
                        .bin   (i_mem_rdata[3:0]),
                        .seg   (HEX0)
                       );
bin2seven_seg u_bin2seven_seg1 (
                        .bin   (i_mem_rdata[7:4]),
                        .seg   (HEX1)
                       );
bin2seven_seg u_bin2seven_seg2 (
                        .bin   (i_mem_rdata[11:8]),
                        .seg   (HEX2)
                       );
bin2seven_seg u_bin2seven_seg3 (
                        .bin   (i_mem_rdata[15:12]),
                        .seg   (HEX3)
                       );
bin2seven_seg u_bin2seven_seg4 (
                        .bin   (i_mem_rdata[19:16]),
                        .seg   (HEX4)
                       );
bin2seven_seg u_bin2seven_seg5 (
                        .bin   (i_mem_rdata[23:20]),
                        .seg   (HEX5)
                       );

// LEDs display memory data [31:24]
assign LEDR[7:0] = i_mem_rdata[31:24];
assign LEDR[8] = start;
assign LEDR[9] = addr_select;


endmodule
